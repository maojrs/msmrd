//
// Created by maojrs on 1/31/19.
//
#include "spherePartition.hpp"

namespace msmrd{

    /*
     * Constructor creates a spherical equal area partition on the surface of a sphere.
     * @param numPartitions the number of sections that the sphere should be partioned in.
     */
    spherePartition::spherePartition(int numPartitions) {
        auto partition = partitionSphere(numPartitions);
        regionsPerCollar = std::get<0>(partition);
        phis = std::get<1>(partition);
        thetas = std::get<2>(partition);
    }

    // Calculates area of cap given polar angle
    double spherePartition::angle_to_cap_area(double phi) {
        return 4 * M_PI * (std::sin(phi / 2.0)) * (std::sin(phi / 2.0));
    }

    // Calculates polar angle corresponding to a given cap area
    double spherePartition::cap_area_to_angle(double area) {
        return 2.0 * std::asin(std::sqrt(area / (4.0 * M_PI)));
    }

    /* Calculate equal area partition of unit sphere with "num_partitions" partitions.
     *  Returns list of three vectors. The first vector indicates number of sections in each
     *  collar (int). The second one indicates location of cuts that define collars in the polar
     *  angle std::vector<double>. The third one denotes the location of azimutal cuts as for each collar,
     *  as a vector for each collar std::vector<std::vector<double>>> .
     *  */
    std::tuple<std::vector<int>, std::vector<double>,
            std::vector<std::vector<double>>> spherePartition::partitionSphere(int num_partitions) {
        //Calculate areas of each state and polar caps angle (phi0 and pi-phi0)
        double state_area = 4 * M_PI / num_partitions;
        double phi0 = cap_area_to_angle(state_area);
        // Calculate the number of collars between the polar caps
        double ideal_collar_angle = std::sqrt(state_area);
        double ideal_num_collars = (M_PI - 2 * phi0) / ideal_collar_angle;
        int num_collars = static_cast<int>(std::max(1.0, std::round(ideal_num_collars)));
        if (num_partitions == 2) {
            num_collars = 0;
        }
        double collar_angle = (M_PI - 2 * phi0) / num_collars;
        // Initialize variables for number of regions in each collar
        std::vector<double> ideal_regionsPerCollar;
        ideal_regionsPerCollar.resize(num_collars);
        std::vector<double> phis;
        phis.resize(num_collars + 2);
        phis[0] = 0;
        std::vector<int> regionsPerCollar;
        regionsPerCollar.resize(num_collars);
        std::vector<std::vector<double>> thetas;
        thetas.resize(0);
        std::vector<double> a{0};
        /* Iterate over each collar to get right number of regions per collar
         * and correct location of phi angles of each collar. */
        double cap_area_phi1;
        double cap_area_phi2;
        double suma;
        double summ;
        unsigned long regsPerCollar_i;
        double dth;
        std::vector<int>::iterator it;
        for (int i = 0; i < num_collars; i++) {
            // Calculate num of regions in collar i
            cap_area_phi1 = angle_to_cap_area(phi0 + i * collar_angle);
            cap_area_phi2 = angle_to_cap_area(phi0 + (i + 1) * collar_angle);
            ideal_regionsPerCollar[i] = (cap_area_phi2 - cap_area_phi1) / state_area;
            regionsPerCollar[i] = static_cast<int>(std::round(ideal_regionsPerCollar[i] + a[i]));
            // Correct values of phi around collar i
            suma = 0;
            for (int j = 0; j < i + 1; j++) {
                suma = suma + ideal_regionsPerCollar[j] - regionsPerCollar[j];
            }
            a.push_back(suma);
            summ = 1;
            for (int j = 0; j < i; j++) {
                summ = summ + regionsPerCollar[j];
            }
            phis[i + 1] = cap_area_to_angle(summ * state_area);
            phis[num_collars + 1] = M_PI - phi0;
            // Obtain list of thetas for a given collar
            regsPerCollar_i = static_cast<unsigned long>(regionsPerCollar[i]);
            std::vector<double> thetasi;
            thetasi.resize(regsPerCollar_i);
            dth = 2.0 * M_PI / regionsPerCollar[i];
            for (int j = 0; j < regsPerCollar_i; j++) {
                thetasi[j] = j * dth;
            }
            thetas.push_back(thetasi);
        }
        regionsPerCollar.push_back(1);
        it = regionsPerCollar.begin();
        regionsPerCollar.insert(it, 1);
        // return number of regions for all collars,
        // phi angles of collars and theta angles for each collar
        return std::make_tuple(regionsPerCollar, phis, thetas);
    }

    /* Assuming partioned sphere sits in origin, given a vector coordinate, find section number
     * that corresponds to section that the line generated by the vector intersects. */
    int spherePartition::getSectionNumber(vec3<double> coordinate, int numPartitions) {
        // Calculate theta and phi of coordinate
        double theta = std::atan2(coordinate[1], coordinate[0]);
        if (theta < 0) {
            theta += 2 * M_PI;
        }
        double r = coordinate.norm();
        double phi = std::acos(coordinate[2] / r);
        int currentCollarIndex;
        int currentThetaIndex;
        // Find intersection of coordinate with section
        int sectionNum;
        int numCollars = phis.size();
        for (int i = 0; i < numCollars; i++){
            if (phi >= phis[numCollars - 1 - i]){
                currentCollarIndex = numCollars-1-i;
                break;
            }
        }
        if (currentCollarIndex == 0) {
            sectionNum = 1;
            return sectionNum;
        }
        if (currentCollarIndex == regionsPerCollar.size()-1) {
            sectionNum = numPartitions;
            return sectionNum;
        }
        std::vector<double> collarThetas = thetas[currentCollarIndex - 1];
        int numThetaCuts = collarThetas.size();
        for (int i = 0; i < numThetaCuts; i++){
            if(theta >= collarThetas[numThetaCuts - 1 - i]){
                currentThetaIndex = numThetaCuts - i - 1;
                break;
            }
        }
        sectionNum = std::accumulate(std::begin(regionsPerCollar),
                                     std::next(std::begin(regionsPerCollar), currentCollarIndex), 0) + currentThetaIndex + 1;

        return sectionNum;
    }

    /* Returns phi-angles (polar) and theta-angles (azimuthal) that correspond to the sectionnumber
     * in the sphere partition */
    std::tuple<std::vector<double>, std::vector<double>> spherePartition::getAngles(int secNumber, int numPartitions) {
        if (secNumber > numPartitions) {
            std::range_error("Error: section number is larger than number of partitions");
        }
        // Get collar
        int collar = 0;
        int sections = 1;
        while (sections < secNumber) {
            collar += 1;
            sections = std::accumulate(std::begin(regionsPerCollar),
                                       std::next(std::begin(regionsPerCollar), collar+1), 0);
        }
        // Find phis
        double phi1 = phis[collar];
        double phi2;
        if (collar + 1 < regionsPerCollar.size()) {
            phi2 = phis[collar + 1];
        } else {
            phi2 = M_PI;
        }
        // Find thetas
        double theta1;
        double theta2;
        std::vector<double> thetasCollar;
        int statesInCollar;
        int prevStates = std::accumulate(std::begin(regionsPerCollar),
                                         std::next(std::begin(regionsPerCollar), collar), 0);
        if ((prevStates == 0) or (prevStates == numPartitions - 1)) {
            theta1 = 0;
            theta2 = 2 * M_PI;
        } else {
            thetasCollar = thetas[collar - 1];
            statesInCollar = secNumber - prevStates;
            theta1 = thetasCollar[statesInCollar - 1];
            if (statesInCollar == thetasCollar.size()) {
                theta2 = 2 * M_PI;
            } else {
                theta2 = thetasCollar[statesInCollar];
            }
        }
        std::vector<double> phiInterval{phi1, phi2};
        std::vector<double> thetaInterval{theta1, theta2};
        return std::make_tuple(phiInterval, thetaInterval);
    }
}
