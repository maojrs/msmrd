//
// Created by maojrs on 1/31/19.
//

#pragma once
#include <vector>
#include <tuple>
#include "vec3.hpp"
#include "quaternion.hpp"


namespace msmrd {
   /*
    * This class creates an equal area partition on the surface of a sphere. It is a c++ copy and extension
    * of the python code in module msmrd2.tools.spherePartition.
    */
    class spherePartition {
    protected:

        // Calculates equal area sphere partition (called by constructor)
        void partitionSphere();

        /*The following three functions should remain outside of the main partition calculation,
         * so it can be easily generalizable to other discretizations (like the half sphere). */
        // Calculates area of cap given polar angle
        double angle2CapArea(double phi);

        // Calculates polar angle corresponding to a given cap area
        double capArea2Angle(double area);

        // Calculates state area (area of each region)
        double stateArea();

    public:
        int numSections;
        double scaling = 1;
        std::vector<int> regionsPerCollar;
        std::vector<double> phis;
        std::vector<std::vector<double>> thetas;
       /* @param numSections the total number of sections of equal area in the partitions
        * The partition is fully encoded into three variables within the class:
        * @param scaling can be used to scale the partition to the half sphere (scaling = 2 instead of 1). However
        * its behavior is not trivial so modify with care.
        * @param regionsPerCollar, vector which size denotes the number of horizontal collars to
        * split the sphere, and the value of each entry the number of sections in each collar. Summing all these
        * values should result in numPartitions
        * @param phis are the locations in the polar angle that one should make the cuts to obtain the corresponding
        * collars.
        * @param thetas each entry of this vector corresponds to one collar (except for the polar caps). Each
        * entry is a another vector with the location in the azimutal angle to make the cuts to obtain the
        * sections in each collar.
        *
        */

        spherePartition() = default;

        explicit spherePartition(int numSections);

        /* Assuming partioned sphere sits in origin, given a vector coordinate, find section number
         * that corresponds to section that the line generated by the vector intersects. */
        int getSectionNumber(vec3<double> coordinate);

        // Given a section number give, phi and theta angles that define the section.
        std::tuple<std::vector<double>, std::vector<double>> getAngles(int secNumber);


        /* Other not so important functions (mostly for PyBindings)*/

        // Returns sphere partition: regionsPerCollar, phis and thetas
        std::tuple<std::vector<int>, std::vector<double>, std::vector<std::vector<double>>> getPartition();

        int getNumSections(){ return numSections; }

        int getSectionNumberPyBind(std::vector<double> coord);

    };

}